# Playgames Platform PRD – *Guessio* Multiplayer Game

## Overview

Playgames (**playgames.team**) is a multiplayer gaming platform launching with its first game, **Guessio**. Guessio is a real-time party game for up to **50 players** in a shared room. In each round, one player enters a secret text prompt; the platform generates an AI image from that prompt using OpenAI’s **GPT-Image-1** model. All other players have **15 seconds** to guess the original prompt by submitting their own text guesses. The system calculates a similarity score between each guess and the secret prompt using cosine similarity of text embeddings (e.g. via OpenAI’s embedding API). Points (0–10 per round) are awarded based on guess accuracy. After each round, the correct prompt is revealed and the **scoreboard** updates for all players. The game consists of multiple rounds (so different players get to be the prompter), and at the end the player with the highest total points wins. To protect privacy, **no user accounts** are required and all game data is ephemeral – once a game ends (or after 24 hours from creation), the session data is deleted from the system.

## Functional Requirements & User Flow

**Core Functional Requirements:**

* **Session-Based Gameplay:** Support creating and joining game sessions without user accounts. Each game session has a unique **join code or link** that serves as the access token for that session. Players simply enter a nickname to join (no login or signup needed). Up to **50 concurrent players** can join a session.
* **Game Lifecycle:** A player can **create a new Guessio game** (becoming the host by default) and share the session code/link with others. Other players use this code to **join the lobby**. The game begins when the host starts it (or automatically if a configured minimum number of players is reached). The platform should support a **lobby phase** where players can see who’s joined and confirm they’re ready.
* **Round Sequence:** In each round, one player is the **“Prompt Giver”** (either the host or selected in turn/rotation). The Prompt Giver enters a text prompt. The system uses OpenAI’s image generation API to create an image from this prompt. This image is then displayed to all players in real time. All other players enter their best guess of the original prompt into a text box, within a **15-second timer**. Each player is allowed one guess per round (which they can submit or update until time is up). After 15 seconds, the round ends: the system **reveals the original prompt** to everyone and computes a similarity score for each guess. Points (0–10) are awarded based on the cosine similarity between the guess text and the original prompt (higher similarity → more points). The scoring algorithm uses vector embeddings and cosine similarity to quantitatively judge how close each guess is to the secret prompt.
* **Real-Time Score Updates:** After each round, the platform updates the cumulative scores leaderboard **in real time** for all players. Everyone can see the points earned that round and total points so far. The game then proceeds to the next round with a new Prompt Giver (e.g. rotate to the next player in the lobby or another selection method) until a predetermined number of rounds are completed or players decide to end the game.
* **End of Game:** When the game concludes (either after a set number of rounds or a manual stop), the final results are shown. The UI should display the winner (highest score) and a full scoreboard. At this point players can choose to start a new game session if they wish. All data from the finished game session should then be **deleted** from the server (with at most a short delay) to maintain the stateless design. A hard **24-hour expiration** is enforced on all game sessions – even if a game is left idle or not properly ended, the backend will automatically remove all associated data after 24 hours from creation.

**User Flow:**

1. **Landing & Game Creation:** A user navigates to **playgames.team** and is presented with a modern, welcoming homepage. They can either **“Start a New Game”** or **“Join Game”**. If starting new, the frontend calls the backend to create a new game session. The user is then shown the **game lobby** screen with the session’s unique code/link prominently displayed for sharing.
2. **Joining a Game:** Other players who receive the invite link or code open the website and choose “Join Game”. They enter the code (if not using a direct link) and a nickname (which must be unique in that lobby). Upon submitting, they enter the **lobby**. The lobby UI lists all connected players’ nicknames and perhaps an avatar or color for each. There is no account login at any point – joining is instant with just the code and nickname.
3. **Lobby & Preparation:** In the lobby phase, players wait until the desired participants have joined. The host can start the game manually (or it may auto-start if the platform opts for that after a certain time or number of players). The UI should make it clear who is the host and possibly indicate who will give the first prompt. Everyone sees a “Waiting for game to start” status.
4. **Round Start:** Once the game starts, the first round begins. The interface indicates who the **Prompt Giver** is for Round 1 (for example: “Player1 is choosing a prompt…”). Only that Prompt Giver gets an input box to enter a prompt (visible only to them, hidden from others). Others see a message like “Waiting for the AI image…”
5. **Image Generation:** The Prompt Giver submits a prompt. The system’s backend calls the OpenAI GPT-Image-1 model API and **generates an image** based on that prompt. A loading indicator or countdown may be shown while the image is being generated. Once ready, the AI-generated image is broadcast to all players’ screens in real time.
6. **Guessing Phase:** As soon as the image is displayed, a **15-second timer** starts (visible to all players). All players *except* the Prompt Giver see a text input for guessing the prompt. They analyze the AI image and type what they think the original prompt was. They submit their guess before the timer runs out (the UI should clearly convey the time remaining). Players can change their guess until the round ends, but only the final submitted guess counts. During this phase, guesses are kept secret (other players do not see each other’s guesses yet, to prevent copying).
7. **Round End & Scoring:** When time is up (or once all players have submitted guesses, if the game auto-terminates the round early), the guessing phase closes. The system now reveals the actual prompt to everyone (“**Original Prompt:** *A robot painting a portrait of a dog*”). It then calculates similarity scores for each guess. The backend uses a text embedding model to compare each guess with the original prompt, computing the cosine similarity. These similarity scores are converted into point values on a 0–10 scale (e.g. exact or very close matches \~10 points, partially related guesses earn mid-range points, completely off-topic guesses get 0). The scoring algorithm details can be adjusted, but it should be consistent and fair for all players. After computation, the platform updates the **scores**: each player’s points for that round (and total points so far) are displayed. This score update is pushed to all clients in real time so that the leaderboard on everyone’s screen refreshes simultaneously.
8. **Next Rounds:** The next round begins with a new Prompt Giver (for example, the role could rotate to the next player in the lobby list). A similar sequence repeats: chosen player enters a prompt, image is generated and shown, others guess, timer, then reveal and scoring. The UI should smoothly transition between rounds, perhaps with a short intermission to let players absorb the results before proceeding. All past rounds’ data (prompts, images, guesses, scores) can remain visible in summary form for players (e.g. a “Round history” view) *during the session*, but this data should not persist beyond the session’s life.
9. **Game Conclusion:** After the final round, the game ends. The final scoreboard is shown, highlighting the winner. There may be an option for the host or players to **play again** (which would start a new session with a new code), or simply exit. Once the game ends, the backend should **terminate the session**: all related data in memory/Redis is flagged for deletion. From this point, no further guesses or prompts can be submitted. If players stay on the page, they might see a message like “Game over – thanks for playing!” and possibly prompt to start a new game. Within the backend, a cleanup process will remove the game session data immediately or shortly after. In any case, **24 hours** after the game was first created, any remaining data (if the game wasn’t properly ended) is automatically purged.

## UX/UI Design Goals

**Look & Feel:** The Playgames platform should have a **beautiful, modern UI** that is inviting and easy to use. We will utilize **Next.js** with **Tailwind CSS** and the **shadcn UI** component library to implement a sleek design system. The style should be clean and playful, matching the fun nature of the game. Visual elements (colors, typography, icons) should be consistent and polished as provided by shadcn’s design tokens, giving a professional and modern aesthetic out of the box. Transitions and animations (for image reveal, countdown timer, score updates) should be smooth and enhance the experience without causing confusion or lag.

**User Experience (UX):** Emphasis is on **ease of use and clarity**:

* **No-Friction Entry:** New users can jump into a game immediately with a single click or code entry – no account creation or login required, ensuring a *“hassle-free experience”*. This lowers the barrier to entry so groups of friends can start playing within seconds.
* **Responsive Design:** The interface must be fully responsive to support desktop, tablet, and mobile web browsers. Layouts should adapt so players on phones can play just as easily as on a desktop (e.g., vertical stacking of image and inputs on mobile).
* **Lobby & Feedback:** The lobby screen should clearly list players and indicate the game status (waiting, starting, etc.). Throughout the game, the UI should provide clear feedback: e.g. when an image is being generated (“Generating image…” spinner), when time is almost up (perhaps a flashing timer), and when scores are updated (highlight score changes). Immediate feedback is crucial for engagement.
* **Game Controls & Prompts:** The design must make it obvious who the current Prompt Giver is and what other players need to do. For the Prompt Giver, the prompt input box should be prominent but only visible to them. For guessers, the image should be front and center, with the guessing input readily accessible below it. A countdown timer should be prominently displayed during guessing. After each round, the correct prompt and scoring breakdown should be shown in a way that players can quickly understand how they did.
* **Visualize Scores:** The score leaderboard should be easily readable. Consider using visual cues (like crown icon for current leader, highlighting the highest score row, etc.). If scores are tied or if there’s a notable best guess, the UI might show that as well.
* **Overall UX:** The flow from round to round should feel intuitive. There should be minimal downtime – while still allowing brief moments for players to react to results (since the social aspect is important). Also, error states should be handled gracefully (e.g., if image generation fails or is slow, show a message and retry option; if a player disconnects, handle their rejoining or mark them as dropped).

In summary, the UX/UI goal is to make the experience **engaging, intuitive, and fast**. By leveraging Next.js and modern CSS frameworks, we aim for an app-like responsiveness. All interactions (joining, guessing, seeing results) should happen in real time without page refreshes, giving a smooth **live multiplayer** feel.

## Guessio Game Flow Details

To ensure a clear understanding of how Guessio plays out, below is a breakdown of the game flow in stages:

* **Lobby Phase:** Players join the game lobby using a session code. The lobby lists all players (nicknames). The host can start the game when ready. The UI might have a “Start Game” button for the host and a ready indicator for others. No gameplay actions occur yet, but players can chat (optional feature) or see game instructions/tips while waiting.

* **Prompt Submission & Image Generation (Round Start):** When a round begins, one player is designated as the **Prompt Giver**. Only that player sees a prompt input UI where they enter a descriptive phrase (e.g. *“a medieval castle on a floating island”*). Upon submission, the backend calls OpenAI’s image generation (GPT-Image-1) to create an image for that prompt. During this short generation time (a few seconds), other players see a loading state (e.g. “AI is drawing the image…”). Once the image is ready, it is immediately sent to all players’ clients via WebSocket and displayed. The round’s guessing phase now begins.

* **Guessing Phase (15s Timer):** As soon as the image is visible, all guessing players see a text input to submit their guess and a visible **15-second countdown**. They attempt to describe what they think the original prompt was. For example, if the image looks like a castle on an island, players might guess phrases like “floating island castle” or “sky island fortress.” Players can submit only one guess (the UI could allow editing until time’s up but after the timer they cannot change it). The real-time aspect is critical: the timer should tick down synchronously for everyone. When the timer reaches zero, the guessing phase closes (any late input is not accepted).

* **Scoring Phase (Round End):** Once guessing is closed, the **Reveal** happens. The original prompt text that the Prompt Giver entered is now shown to everyone (so players can compare it to their guesses). The system evaluates each guess’s similarity to the actual prompt. This is done by converting the prompt and guess into high-dimensional text embeddings and computing cosine similarity between them. A similarity score (e.g. 0.0 to 0.99) is then mapped to the **0–10 point scale**. We might define thresholds or a linear mapping for clarity (for instance, 100% identical or extremely close = 10 points; very high similarity = 8–9 points; moderate similarity = 5 points; low similarity = 1–2; no discernible similarity = 0). The exact distribution can be tuned, but it must be consistent. All players then see the round results: typically a list of guesses alongside the original prompt and points awarded to each player for that round. The **scoreboard** is updated cumulatively – adding the new points to each player’s total. This update is broadcast instantly so that everyone’s view reflects the new totals. A brief celebration animation could play for the player(s) who got the highest points in that round or if someone guessed very closely. Players also get feedback on their own guess (how close it was). This stage offers a moment of surprise and learning, as players discover the actual prompt and see how close/far their guesses were.

* **Next Round Transition:** The game then transitions to the next round. The role of Prompt Giver passes to another player (e.g. in clockwise order of join, or random selection ensuring everyone gets a turn if possible). The UI might indicate “Next up: *Player2* will give a prompt.” When ready, that player enters their prompt and the cycle repeats (image generation -> guessing -> scoring). All previous rounds’ data can be accessible via a “round history” panel during the game if needed, but the main focus is on the current round.

* **Final Results & Cleanup:** After the final round (e.g., after each player has been Prompt Giver once, or a fixed number of rounds), the game ends. The **Final Scoreboard** is shown prominently, declaring the winner. This screen might allow players to share the outcome on social media or copy a link to invite others to a new game. Since the platform does not retain data, if players want to play again they will start a fresh session (there’s no persistent account leveling or such – it’s meant for casual play). Once the game is over, the system triggers the deletion of the game data on the server side. If a game is abandoned mid-way, the system will still automatically remove the data after 24 hours of inactivity for safety.

Throughout the game flow, **ephemeral data** is used – meaning that everything resets after the game. The design ensures that each session is isolated and no personal data is stored long-term, aligning with the stateless, privacy-first approach.

## Architecture Overview (Next.js, Node.js Server, WebSockets, Redis)

**Architecture Summary:** The platform is built as a **monorepo** containing a Next.js frontend and a lightweight Node.js/Express backend for game logic and real-time communication. The design is **stateless** and horizontally scalable – no server holds persistent session state in memory; instead, game state is stored in an external in-memory datastore (**Redis**) with short time-to-live. Real-time updates are delivered via **WebSockets** on the Node.js server, enabling instant bidirectional communication between clients and the server. This design choice (using a separate state store and pub/sub) allows the WebSocket server to remain stateless and easily scalable if needed.

Key components in the system include:

* **Next.js Frontend:** Serves the web application UI (built with React and Tailwind CSS). Next.js handles the initial page loads and UI routes. It can pre-render pages (like the landing page or lobby) for fast loads. Once loaded, the frontend opens WebSocket connections for real-time game interaction. The Next.js app will likely be deployed on **Vercel**, taking advantage of serverless functions for any API routes if needed. The UI code (React components styled with Tailwind and shadcn UI) runs in the browser for snappy interactivity. All UI actions (join game, submit prompt, send guess) call either REST endpoints or emit WebSocket events to the backend.

* **Node.js/Express Game Server:** This is a custom server (in TypeScript) responsible for orchestrating game rounds and maintaining state in memory/Redis. It handles WebSocket connections from players: when a player joins a game, the client either opens a socket to a route (e.g. `wss://playgames.team/game/<gameId>`) or upgrades a HTTP request to WebSocket. The server identifies the game session from the URL or a token, and then subscribes the socket to that game’s channel. We use a **Pub/Sub model** via Redis to broadcast messages to all players in a game room, which keeps the design stateless and scalable. For example, if we run multiple Node.js instances (to support more load), each instance can subscribe to Redis channels so that a message published to “game\:XYZ” channel will reach all players in game XYZ no matter which server their socket is connected to. In our initial deployment, a single server instance might suffice (50 players is not heavy load), but the groundwork for horizontal scaling is there: *“The WebSocket server (backend) subscribes to Redis channels and forwards messages to clients, and Redis Pub/Sub distributes messages across instances”*. The Express server also exposes a few **RESTful API endpoints** (e.g., to create a new game, or for the image generation call if not done directly in WS) – these can be implemented as Next.js API routes or within Express, depending on deployment. All server logs and operations will be kept minimal and stateless. We rely on Vercel’s logging for any serverless function logs, and the Node server itself will not write user data to disk.

* **OpenAI API (Image Generation):** The backend integrates with OpenAI’s GPT-Image-1 (or equivalent) through API calls. When a prompt is submitted, the server sends the request to OpenAI and awaits the generated image. The image (likely returned as a URL or binary) is then forwarded to clients. This external service is stateless relative to us – we do not store images permanently. We might cache the image in memory or Redis briefly for the 15-second guessing duration (to resend to any late-joining client, for example), but it will be removed after the round.

* **Redis (Ephemeral Data Store & Pub/Sub Broker):** Redis is central to maintaining game state without persistent storage. It stores active game sessions and their data (players, prompts, scores, etc.) and is configured to **auto-expire keys** so that data is removed when no longer needed. We use Redis both as a direct data store and via its **Pub/Sub** mechanism. For each active game, the backend may have a Redis key like `game:<gameId>` holding the game state (player list, scores, current round info, etc.). This key is set with a TTL (time-to-live) of 24 hours upon creation so that it will be deleted automatically after a day. Additionally, when the game ends, the server can explicitly delete this key to free memory immediately. Redis Pub/Sub is used to propagate real-time events: for example, when a player submits a guess, the server might publish a message on channel `game:<gameId>` which all connected sockets (via the Node server) receive, or simply use the Node server to broadcast directly. In a multi-instance scenario, publishing via Redis ensures all instances deliver the message to their local clients. This architecture (WebSocket server + Redis pub/sub) is a proven pattern for scalable real-time systems. It means the WebSocket server instances do not need to share in-memory state; they all refer to Redis. Notably, **no traditional database** is used – there is no need to persist game data beyond the session. Redis, being in-memory, provides extremely fast reads/writes which is ideal for quick updates like scoring and timeouts.

* **Deployment & Scalability:** All components are intended to be deployed in a cloud environment. The Next.js frontend will be deployed (likely on Vercel) for global CDN reach and fast static asset serving. The Node/Express server can be deployed alongside (possibly as a Vercel Serverless Function or an Edge Function if WebSocket support is available, or as a separate Node service on e.g. Heroku/Fly.io). The Redis instance can be a managed service (like Upstash for serverless Redis or Redis Cloud) and will be configured with max 24h persistence and an eviction policy if needed (though data volume is small). Because the system is stateless, we can run multiple server instances behind a load balancer if needed, and all instances will coordinate via Redis. In fact, every component here can scale horizontally – the WebSocket server could be replicated to handle more users, and because state is externalized, it won’t break consistency. This ensures that as the platform grows, it can support many concurrent games and players (the architecture could even serve thousands of players across games, given adequate resources).

*Diagram (Suggested):* In a typical deployment, **Next.js** handles initial page requests, serving the HTML/JS. Once a user joins a game, their browser opens a **WebSocket** connection to the **Node/Express server** (which may be running as a Vercel function or a container). The Node server authenticates the connection (verifying the game token) and subscribes it to the game’s channel. The **Redis** store holds the game state (with a TTL) and brokers messages: the Node server uses Redis to publish events (like “newGuess” or “scoreUpdate”) which are received by all subscribers for that game, including possibly itself. The Node server then relays those events to clients via WebSocket. Similarly, if we had multiple Node servers, they all listen on the Redis pub/sub so a publish from one is received by the others. The **OpenAI API** is an external call from the Node server whenever an image needs to be generated. No game data is stored on disk; all is in-memory (Redis or Node runtime) and ephemeral.

## Redis Ephemeral Storage & Real-Time Configuration

Using **Redis** for ephemeral storage and message broadcasting is a crucial design choice. Here we outline how Redis is configured and used in Playgames:

* **Ephemeral Session Storage:** Each game session’s state is stored in Redis as a set of keys or a structured value, and each is set to **expire automatically**. For example, when a new game is created, the server will create a key like `game:<sessionId>` (could be a Redis hash or JSON string) containing all necessary info: list of players, their nicknames, scores, current round number, etc. This key is given a **Time-To-Live (TTL)** of 24 hours (86400 seconds). We use Redis’s `EXPIRE` command for this, meaning after 24 hours the key *“will automatically be deleted”* by Redis. A volatile key strategy ensures that even if a game isn’t explicitly terminated (e.g. users close the browser without ending), the data won’t persist beyond a day. In practice, we may also remove it sooner: when a game ends normally, the server can issue a `DEL` or set a very short TTL on the key so that it’s cleaned up promptly. This double approach (explicit deletion on game end and TTL as a backup) guarantees ephemeral data retention only for the intended duration.

* **Redis Data Structures:** For quick lookups and updates, we can use a Redis **Hash** for game state (e.g. `game:<id>` hash with fields: `players`, `scores`, `round`, etc.) or store a JSON blob. Player scores might also be stored in a Redis Sorted Set (`scores:<gameId>`) to easily retrieve rankings, though for up to 50 players a simple hash or list is fine. Each player might have a sub-key or just be part of the game hash. All these keys would share the same TTL under the game session umbrella. The exact schema can be optimized, but the guiding principle is to keep data minimal and transient.

* **TTL and Expiry Handling:** We trust Redis’s built-in expiration to remove old sessions. It’s worth noting that Redis expirations are not to-the-millisecond precise; keys are checked periodically for expiry. Redis might not delete the key at the exact 24h mark if the key hasn’t been accessed, due to its lazy expiration mechanism. However, Redis will generate an *expired event* when it actually deletes the key. To ensure reliability, we can enable **Keyspace Notifications** for expired events on Redis. This way, the server (or a monitoring script) can subscribe to Redis’s `__keyevent@0__:expired` channel and be alerted whenever a game key expires. This is useful for logging or any cleanup callbacks (though in our case, simply letting it expire is enough). We should configure Redis with `notify-keyspace-events = Ex` (for expire events) if we plan to use this monitoring.

* **Pub/Sub for WebSocket Events:** Redis Pub/Sub is used to coordinate real-time messages. For each game session, we can designate a **channel** named `game:<sessionId>` (or a similar unique topic). The Node server will subscribe to this channel when a game is active. All events that need to be broadcast to all players are published on this channel. For example, when the Prompt Giver’s image is ready, the server might publish a message `{"event":"imageReady","data":<image_url>}` on `game:<id>`; all subscribers (including possibly the same server or others) receive it and can then emit it to the clients via WebSocket. Similarly, each guess submitted could either be published or handled directly and then one publish after all guesses collected for the round. If we use Socket.io (or a similar WS library), it often provides a room mechanism – in a single-server scenario, we might not need Redis pub/sub for broadcasting since Socket.io can broadcast to all sockets in a room. **However**, for future scalability or multi-server, we will use a Redis-based adapter so that broadcasts go through Redis to reach clients on any server. Essentially, the **WebSocket server acts as a subscriber to Redis**: *“The server subscribes to Redis channels and forwards messages it receives through pub/sub to connected clients.”*.

* **Redis Configuration:** We will run Redis in an ephemeral mode. No RDB or AOF persistence is strictly required (we could disable disk persistence for performance, since data loss is acceptable if the service restarts – ongoing games would simply be dropped). The memory usage will be low (each game storing perhaps a few KB at most, which for dozens of games is trivial). We will set a maxmemory policy if needed (e.g. `allkeys-lru` or `allkeys-lfu`) just in case, but with auto-expiry and low usage this may never trigger. The crucial config is the expiration – ensure every game key gets an expiration on creation. Additionally, we might leverage Redis **Pub/Sub** or **Streams** for event queueing. Basic Pub/Sub suits our needs since we don’t need message durability (if a player is disconnected, they simply miss the message and the app can handle reconnection logic if necessary). We should also ensure Redis is configured to allow the needed number of pub/sub connections (50-player games \* number of games, but realistically a single Redis instance can handle thousands of channels and subscribers easily).

* **Security:** Although Redis will contain only ephemeral game data, we should still protect it. The game session IDs/tokens should be unguessable (use random UUIDs or similar) to prevent unauthorized access. Even if someone did connect to Redis, without the specific keys or subscribe channels they can’t do much. We may set a Redis password and connect over TLS if available, especially if using a cloud service.

In summary, Redis is the **single source of truth** for game state during a match, and its TTL mechanism ensures that *“when the time comes, the key will expire and be deleted automatically”*. By using Redis both for storage and pub/sub messaging, we keep the backend stateless and responsive. This ephemeral design meets the requirement that **game data self-destructs after 24 hours**, and usually much sooner (at game end).

## API and WebSocket Design Overview

The platform exposes a minimal set of **REST API endpoints** and primarily uses **WebSocket** messages for real-time game functionality. All interactions are scoped to a game session via an **auth token (session ID)**. Below is an overview of the API and WS design, including authentication and update flows:

**Authentication & Session Management:**
There are no persistent user accounts. Authentication is handled per session using a **game session token or code**. When a game is created, the backend generates a unique identifier (e.g. a 6-character alphanumeric code or a UUID) for that game. This is the “join token” that players use. For simplicity, this token also serves as the authentication key to join via WebSocket. For example, the client might connect to `wss://playgames.team/ws/<gameToken>` to join that game’s channel. Alternatively, the join flow could be: client calls a **Join Game API** with the code and nickname, the server responds with a one-time **session token** (like a JWT or random player ID) plus the WebSocket endpoint. In implementation, we could simply trust the code on the WebSocket connection as authentication, since the server will verify it against existing games in Redis. Each player in the game is assigned a temporary **player ID** (which could just be a UUID or their socket ID), and the server maps it to their nickname in the game state. All subsequent communications over that WebSocket implicitly carry the player’s identity (we know which socket corresponds to which player). We ensure that only clients with a valid session token can join a game and that each game doesn’t exceed 50 players. Because there’s no broader account system, there’s no need for OAuth or long-lived tokens – all auth is short-lived and tied to the session. This provides a *“hassle-free”* join experience but still ensures that random outsiders cannot inject into a game without the code.

**REST API Endpoints:** (tentative list)

* `POST /api/create-game` – **Create Game**: Creates a new Guessio game session. No auth required (or could be protected by a simple admin key if we want to limit who can create games, but likely open). The server generates a session ID/code, initializes a Redis record for the game (with TTL), and returns the game token. Optionally, the request can include the host player’s nickname, which the server will register as the first player (host) in the game state. Response contains: `{ gameId: <code>, hostToken: <token>, websocketURL: <wss_url> }`. (If not using a separate token, the gameId itself might be used in the WS URL along with a flag indicating this player is host).
* `POST /api/join-game` – **Join Game**: (This could be handled entirely via WebSocket connect, but we might have an HTTP endpoint for convenience). The client provides a game code and desired nickname. Server checks if the game exists and isn’t full. If all good, it adds the player to the Redis game state (with an initial score of 0) and returns a success (and perhaps a generated player token or just instructs client to now open the WebSocket). If game not found or full, returns an error. This step might be skipped if the client directly opens a WebSocket and sends a “join” event, but an HTTP join helps perform the Redis setup and avoid handling that in WS handshake.
* `GET /api/game-state/<gameId>` – **Get Game State**: This could be optional, but it would allow a client that refreshes or reconnects to fetch the current state of the game (players list, scores, current round info). Since our game is short and real-time, we might not need this (the WebSocket events keep everyone updated), but it’s useful for recovery on reconnect. The endpoint would read from Redis and return the game data. This might be protected by requiring the session token.
* **OpenAI Image Endpoint**: Instead of exposing this directly, the server might handle image generation internally. But if needed, an endpoint like `POST /api/generate-image` could be used (with game and prompt info) to trigger image generation. However, doing it via WebSocket (client sends prompt event, server responds with image event) is more seamless. So we likely **won’t expose the AI API to the client**; the server will call OpenAI behind the scenes when appropriate.

All these HTTP endpoints would be part of the Next.js API routes or Express server. They will log minimal info (and Vercel’s default logging will capture requests). No sensitive data is stored; the only identifiers are random game and player tokens.

**WebSocket Messaging Protocol:**
Once connected to the WebSocket, clients and server exchange messages in a predefined format (likely JSON). Key message types include:

* **Join**: *(Client → Server)* After opening the socket, the client sends a message like `{ action: "join", gameId: "<code>", nickname: "Alice" }` if not already handled via API. The server validates and either accepts (adding the player) or denies (invalid code or nickname taken). On success, the server could respond with a confirmation and the current state `{ action: "join_ack", success: true, players: [...], you: "<playerId>" }`. Then the server broadcasts to others `{ action: "player_joined", nickname: "Alice" }` so that everyone updates their lobby list in real-time. This ensures all players see the new entrant immediately. (If join was done via REST, the server would have separately broadcasted a new-player event via WS as well.)

* **Start Game**: *(Client → Server)* Likely only the host can initiate. Message: `{ action: "start_game" }`. Server verifies sender is host and that game hasn’t started yet, then updates state (mark game as started, pick first Prompt Giver) and broadcasts `{ action: "game_started", promptGiver: "<playerName>" }`. All clients then transition from lobby UI to game UI.

* **Submit Prompt**: *(Client → Server)* The Prompt Giver sends their secret prompt to the server: `{ action: "submit_prompt", prompt: "a castle on a floating island" }`. Server receives this, maybe sanitizes it (and possibly checks against content filters if needed), then acknowledges. The server then calls the OpenAI image API with this prompt. While waiting, it could broadcast to others a message like `{ action: "image_generating", round: X, promptGiver: "<playerName>" }` to let players know to get ready. When the AI image is received, the server stores the prompt (hidden from others) and the image (perhaps as a URL or base64 string). It then broadcasts `{ action: "image_ready", image: "<some_image_data>", round: X }` to all players. Clients display the image and the guessing timer begins on the client side (or we can include a timestamp and let clients countdown).

* **Submit Guess**: *(Client → Server)* When a player guesses, they send `{ action: "submit_guess", guess: "<player's guess text>" }`. The server records this guess in Redis under that player for the current round. It might immediately acknowledge with `{ action: "guess_received", player: "<id>" }` (or simply remain silent until scoring). We do not broadcast guesses to other players at this time to keep them hidden. If a player changes their guess, they can send the event again; the server will update the stored guess if time still remains.

* **Timer & Round End**: The 15-second timer can be managed in two ways. Either the **server is the source of truth for the timer** (it starts a timeout when image is sent and when it expires, it moves to scoring), or the clients manage their own timers and the server trusts them to stop (not ideal for cheating reasons). It’s better that the server enforces the round end. For example, when the server broadcasts `image_ready`, it notes the end time (now + 15s). The server could broadcast countdown ticks (optional, likely unnecessary) or simply a final `{ action: "time_up" }` at 15s. When time is up, the server stops accepting `submit_guess` messages. It then proceeds to scoring.

* **Scoring & Results**: The server now has the original prompt and each player’s guess. It computes similarity scores (this might involve calling an embedding API like OpenAI’s or using a local model). After computing, it updates the Redis scores for each player. Then it broadcasts a message to all: `{ action: "round_end", prompt: "<original prompt>", results: [ {player:"Alice", guess:"floating castle", points:8}, {...} ], scores: [ {player:"Alice", total:18}, ... ] }`. This single message gives clients all they need to update the UI: show the original prompt, each guess with points (could be used to display a results table for that round), and the updated total scores for the leaderboard. All clients update their state accordingly. The message might also indicate who will be Prompt Giver next (if determined).

* **Next Round**: If another round is to start, the server sends `{ action: "next_round", promptGiver: "<name>" }` to indicate the next round’s roles, or it might combine this with the round\_end message (like including next Prompt Giver). The clients then reset their UI for the next round (clear guess inputs, etc.) and wait for the `image_ready` of the new round. The flow repeats with **submit\_prompt** from the new Prompt Giver.

* **Game End**: When the last round finishes, the server broadcasts `{ action: "game_over", finalScores: [ {player:"Alice", total: X}, ... ] }`. The clients then know the game is over and can show the final outcome. After sending this, the server will close the game room – further messages are ignored. Shortly after, it deletes the game data in Redis (or sets an expiration very soon).

* **Other Messages**: We should also handle minor events: e.g., **Player Leave** – if a player disconnects (WebSocket closes), the server can broadcast `{ action: "player_left", player: "<name>" }` so others know. The server will remove them from the game state. If the Prompt Giver disconnects mid-round, the server might choose to abort the round or assign another Prompt Giver (edge case to design for). **Error** – if any error occurs (invalid message, server exception), server can send `{ action: "error", message: "Description" }`. Also, perhaps a **Ping/Pong** message to keep connection alive (or we use WebSocket native ping frames or rely on Socket.io’s heartbeats).

**Real-Time Updates:**
All state changes are pushed to clients via WebSockets immediately. Players joining or leaving, new image ready, timer events, guesses (optionally one could notify that “X has made a guess” without revealing it), round results – everything uses the pub/sub + WS pipeline. This ensures a highly interactive experience with minimal latency. The use of WebSockets means we avoid constant polling; updates occur *“as things happen”*, which is ideal for a game scenario.

**Security for WS/API:** We will ensure that a player can only act within their game. The gameId token in messages prevents cross-game data mix. We’ll also validate on server side that, for example, only the chosen Prompt Giver’s socket can send a `submit_prompt` for that round, only active players can send guesses, etc. This prevents any malicious client from impersonating actions. The per-session token might be used to sign messages (or simply the server trusts its internal mapping of socket to player to game). All communication can be considered transient; however, we’ll employ SSL (wss and https) so that data (like prompts/guesses) is encrypted in transit.

Overall, the API surface is small since the game logic is mostly driven by WebSocket events. The combination of a quick REST join and then live WS messages will cover all interactions. This design meets the requirement for **stateless, token-based auth** and **real-time updates** to all players.

## Monitoring & Session Data Deletion Reliability

Since Playgames is built on ephemeral sessions, we must ensure that session data is properly cleared and monitor that the system remains healthy over time. Below are strategies for monitoring game sessions and ensuring deletion reliability:

* **Automated Expiration (TTL) Auditing:** We rely on Redis TTL for automatic cleanup of game data. To verify this is working as expected, we can enable logging or notifications for key expirations. By turning on Redis keyspace notifications for expired events, the system can listen and log an entry each time a game key is removed due to TTL. These logs (visible in Vercel or our monitoring console) will confirm that games do get deleted after 24h or on manual end. If we notice keys lingering beyond their TTL, that would flag an issue in our cleanup process.

* **Explicit Cleanup on Game End:** As a safeguard, whenever a game ends normally, the server will explicitly delete its Redis keys (or set a very short TTL) immediately. We will log this action (e.g., “Game XYZ ended, data deleted”). By observing these logs, we can track how often games end vs. how many expire by TTL. Ideally, most will be cleaned up on end, and TTL catches any that were abandoned.

* **Resource Monitoring:** We should monitor Redis memory usage and the count of active game keys. If the system is healthy, the number of active games should correlate with actual usage (e.g., if at 3AM no one is playing, there should be \~0 active games in Redis). If memory or key count only grows and never drops, that indicates expiration might not be happening. Tools like Redis’ INFO command can show number of keys and memory used. We could set up a simple scheduled function (maybe a daily cron job) that checks Redis for any keys older than expected and reports them. However, given the low volume and TTL, manual monitoring might suffice initially.

* **Logging and Alerts:** Even though we are not storing extensive logs (and will use Vercel’s default logging), we can still set up basic alerts. For example, if an exception occurs during game deletion or if the Redis TTL fails to set, the server could log an error. We should configure Vercel or a log management service to catch any spikes in errors. Additionally, if using an uptime monitor, we can periodically ping an endpoint that returns the number of active games (just for monitoring). If that number grows without bound or doesn’t decrease after a day, it would alert us to a cleanup failure.

* **Simulated Expiry Testing:** During development, we can test the deletion reliability by using shorter TTLs (say 30 minutes) and starting games in a staging environment, then ensuring they disappear from Redis after TTL. We can also test manual deletion by ending games and verifying the keys are gone immediately. These tests will be part of our QA to ensure no data remains unexpectedly.

* **Redis Maxmemory Policy:** If for some reason a key wasn’t deleted, Redis’ maxmemory policy (if set) could evict it when memory is needed. We might set a moderate maxmemory for Redis to avoid unbounded memory usage. In the unlikely event that keys persist, Redis would eventually evict old keys under an LRU policy. That’s a last-resort safety net to prevent memory leaks from affecting the service.

* **Session Timeout Handling:** The 24h TTL is from game creation time. If a game is active for a very long time (e.g., someone leaves a browser open and keeps playing sporadically), there’s a possibility the TTL could remove the game while players are still in it (24h later). To handle this, we might refresh the TTL on certain activity (like on each round start or player action) *if* we want the 24h to count from last activity rather than creation. But the requirement says 1 day from creation strictly, likely for privacy. So we will likely not extend TTL, meaning a game will be force-terminated at 24h regardless. We should monitor if any active game hits that limit. We can implement a warning: e.g., when a game hits 23 hours, send a message to players “Session will expire soon”. This is a rare edge case but worth noting.

* **Reliability of Deletion:** Redis expirations are generally reliable, but as the docs note, *“expired events are generated when the server deletes the key, not exactly when TTL hits zero”*. This means there can be a short delay in actual deletion if the key isn’t accessed. To improve reliability, our explicit deletions on game end are crucial. Also, when a player tries to join or interact with a game that has technically expired (TTL reached), the first access will cause Redis to realize it’s expired and delete it. The server will then get a “key not found” and can treat the game as non-existent. We will handle this gracefully (telling the user the session expired and maybe to start a new game).

* **Monitoring Tools:** If this platform grows, we may integrate monitoring solutions. For example, **Prometheus/Grafana** for metrics (number of games created, active users, memory usage, WS connections), and set up alerts if, say, memory usage spikes or unusual activity occurs. Initially, given the small scope, we can rely on simpler logging and the managed infrastructure’s analytics (Vercel analytics for function invocations, etc.).

* **Default Logging (Vercel):** We will use Vercel’s logging for serverless functions to keep records of API calls. Since we don’t store logs elsewhere long-term, any sensitive data in logs should be minimized. But we can log events like “Game X created by \[IP]” or “Game X expired after 24h” for debugging and trust Vercel’s rotation to purge them eventually.

* **Failure Scenarios:** In case the Node server crashes or restarts (on Vercel this could happen as functions spin up/down), the state is still safe in Redis. When the server process comes back up, it will not automatically re-subscribe to old games (since those would likely be gone or expiring soon). This is fine; if a crash happens mid-game, that game might be interrupted – but since we’re not aiming for 100% uptime on a single session, this is acceptable. However, we should monitor server crashes. If our WebSocket server is containerized, ensure it’s restarting on failure and maybe alert on repeated crashes.

In conclusion, **monitoring ephemeral sessions** involves checking that keys expire as intended and no stale data lingers. By using Redis’s expiration events and careful logging of game lifecycle events, we can be confident that the platform respects the 24-hour data retention policy. This approach, combined with the inherent ephemeral design (no persistent storage to begin with), will make Playgames a lightweight, privacy-conscious system that nonetheless can be observed and debugged for any issues in real time.
